\section{Approach 1: A Single-Thread program}
\begin{tcolorbox}{gray!20!white}
    \begin{lstlisting}[language=C, caption=Single-Threaded Pi Calculation]
        #include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>
const int W = 800, H = 800;

double rand_double(unsigned int *seed, double a, double b) {
    double r = (double)rand_r(seed) / (double)RAND_MAX;
    return a + r * (b - a);
}
unsigned long long int count_point_inside(unsigned long long int n_point, unsigned char *img);
void fill_background(unsigned char *img, int W, int H,
                     unsigned char r, unsigned char g, unsigned char b) {
    for (int i = 0; i < W * H; i++) {
        int idx = i * 3;
        img[idx+0] = r;
        img[idx+1] = g;
        img[idx+2] = b;
    }
}




int main(int argc, char *argv[]) {
    unsigned long long npoints = 10000000ULL; // mặc định

    if (argc > 2) {
        fprintf(stderr, "Usage: %s [number_of_points]\n", argv[0]);
        return 1;
    }
    if (argc == 2) {
        char *endptr = NULL;
        unsigned long long val = strtoull(argv[1], &endptr, 10);
        if (endptr == NULL || *endptr != '\0' || val == 0) {
            fprintf(stderr, "Invalid number: %s\n", argv[1]);
            return 1;
        }
        npoints = val;
    }
    unsigned char *img = (unsigned char *)calloc(W * H * 3, 1);
    if (!img) { perror("calloc"); return 1; }
    unsigned int seed = (unsigned int)time(NULL) ^ (unsigned int)(36 * 0x9e3779b9);
    srand(seed);
    fill_background(img, W, H, 255, 255, 255);
    
    struct timespec t0, t1;
    clock_gettime(CLOCK_MONOTONIC, &t0);

    unsigned long long inside = count_point_inside(npoints,img);
    clock_gettime(CLOCK_MONOTONIC, &t1); // Lấy thời gian kết thúc
    double elapsed_sec = (t1.tv_sec - t0.tv_sec) +
                     (t1.tv_nsec - t0.tv_nsec) / 1e9;
    printf("Elapsed: %.6f s\n", elapsed_sec);
    FILE *f = fopen("points.ppm", "wb");
    if (!f) { perror("fopen"); free(img); return 1; }
    fprintf(f, "P6\n%d %d\n255\n", W, H);
    fwrite(img, 1, W * H * 3, f);
    fclose(f);
    free(img);
    double pi = 4.0 * (double)inside / (double)npoints;
    printf("Points: %llu Inside: %llu Pi ≈ %.10f\n", npoints, inside, pi);
    return 0;
}
unsigned long long int count_point_inside(unsigned long long int npoints, unsigned char *img){
    unsigned long long inside = 0ULL;
    for (unsigned long long i = 0; i < npoints; i++) {
        double x = -1.0 + (double)rand() / (double)RAND_MAX * 2.0; // [-1,1]
        double y = -1.0 + (double)rand() / (double)RAND_MAX * 2.0; // [-1,1]
        if (x * x + y * y <= 1.0) inside++;
        int px = (int)((x + 1.0) * 0.5 * (W - 1));
        int py = (int)((y + 1.0) * 0.5 * (H - 1));
        if (px >= 0 && px < W && py >= 0 && py < H) {
            int idx = (py * W + px) * 3;
            double r2 = x*x + y*y;
            img[idx + 0] = (r2 <= 1.0) ? 0 : 255;   // R
            img[idx + 1] = (r2 <= 1.0) ? 255 : 0; // G
            img[idx + 2] = (r2 <= 1.0) ? 0 : 0;   // B
        }
    }
    return inside;
}
    \end{lstlisting}
\end{tcolorbox}